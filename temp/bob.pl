#!/home/aruba/bin/gnu/isqlperl
# use Test::Harness;
# use DB_File;
# use strict 'untie';
# Initial revision
#
#

$HEADER = 1;
$SCAN_DELAY = 30;          # Delay time in seconds between scans of tables
$SCAN_COUNT = 10000;           # Number of times to scan

# For SUBJECT Processing
$gTempFileName = "temp.txt";
$gPartNum = 1;
$gTotalParts = 1;
$gAuthor;
$gKeycodes;
$gErrorCount;

# These are the text that starts lots of common lines we want to
# filter out of text files. If a line begins with one of these,
# it will be removed.

@gFilterLines = (
    "           http://www.arcticera.com/stories",
    "         http://www.arcticera.com/stories",
    "-----= Posted via Newsfeeds",
    "-----==  Over 80,000 Newsgroups",
    "Approved: ",
    "Before you buy",
    "Bytes: ",
    "Cache-Post-Path: ",
    "Comments: ",
    "Content-Disposition: ",
    "Content-Transfer-Encoding:",
    "Content-Type: ",
    "Courtesy: ",
    "Date: ",
    "Did you like this story",
    "Do you love to read about sex",
    "Followup-To: ",
    "Get Your Private, ",
    "Lines: ",
    "MIME-Version: ",
    "Message-ID: ",
    "NNTP-Posting-Date: ",
    "NNTP-Posting-Host: ",
    "Organization: ",
    "Path: ",
    "References: ",
    "Reply-To: ",
    "Sent via Deja.com",
    "This is a multi-part message in MIME format",
    "User-Agent: ",
    "X-Abuse-Info: ",
    "X-Accept-Language: ",
    "X-Admin: ",
    "X-Archived-At: ",
    "X-Article-Creation-Date: ",
    "X-Cache: ",
    "X-Comment",
    "X-Complaints-To:",
    "X-Envelope-From: ",
    "X-Http",
    "X-MSMail-Priority: ",
    "X-Mailer: ",
    "X-MimeOLE: ",
    "X-Moderator-Contact: ",
    "X-Moderator-ID: ",
    "X-MyDeja",
    "X-Newsreader: ",
    "X-No-Archive: ",
    "X-Newsposter: ",
    "X-Original-Message-ID: ",
    "X-Original-Path: ",
    "X-Originating-Host: ",
    "X-Priority: ",
    "X-Property: ",
    "X-Remailer-Contact: ",
    "X-Report: ",
    "X-Sender: ",
    "X-Server-Date: ",
    "X-Story-Submission: ",
    "X-Trace: ",
    "X-WebTV-Signature: ",
    "X-Wren-Trace: ",
    "Xref: ",
    "________________",
    "get off at http://dreemluvr",
    "http://www.incestdreams.com/index.html",
    "http://www.newsfeeds",
	);

$gSubject;
@gText;
@gStandingFile = (  "bu10_score_98.html",
                    "bu12_score_98.html",
                    "bu14_score_98.html",
                    "gu10_score_98.html",
                    "gu12_score_98.html",
                    "gu14_score_98.html"
				 );
@gTable = ();
@gWebText = ();		# Will contain the html code for a single soccer team
					# game schedule.

@gTeamSched = ();  	# Each row contains a string that represents 1 game.
@gWebaTLA = ();	# This array contains the name of every web page
					# generated by this code.  It is used to create an
					# aTLA page that links to each teams individual
					# game schedule.

@gTemplateTop;		# Holds the top of the template.html file
@gTemplateBottom;	# Holds the bottom of the template.html file.
$gTEMPLATE_FILE = "template.html";
$gSCHED_TEMPLATE_FILE = "sched_template.html";
$gSCHED_aTLA_OUTFILE = "sched_aTLA.html";



&main ();
exit (0);

#-------------------------------------------------------------------------
# S_AnalyzeFormat
# This routine will attempt to analyze the format of each text file.
#-------------------------------------------------------------------------
sub S_AnalyzeFormat
{
	local ($aFileName) = @_;
	local ($lInFile, $lOutFile);
	local ($lOutFile);
	local ($lCmd);

	# See if the parent routine gave us a file name
	if ( length ($aFileName) < 1 )
	{
		# Get the input file name
		system ("cls");
		printf "File Name: ";
		$lOutFile = <STDIN>;
		chop ($lOutFile);
	} else {
		$lOutFile = $aFileName;
	}

	if ( length ($lOutFile) > 3 ) {
		printf "Analyzing format for ($lOutFile)\n";

		# Create a unique file name for the temporary file
		$lInFile = "_" . "$lOutFile";

		# delete any temp file that is left over
		&S_EraseFile ($lInFile);
		system ("rename $lOutFile $lInFile");

		# Call a routine to analyze the format
		#
		#

		&S_DoFormatAnalysis ($lInFile, $lOutFile);
		print "Format lines added. (Input/Output): ($lInFile / $lOutFile)\n";

	} else {
		printf "** NO INPUT FILE SPECIFIED **\n";
	}

	# Now make sure we did not cut our file in half
	&S_TestFileSizes ($lInFile, $lOutFile);

}	# S_AnalyzeFormat

#-------------------------------------------------------------------------
# S_GetFormatCode
# This routine will examine the @gText array and analyze the body of
# the text so later routines can reformat it.
# Format Codes:
#	0 - Text is left-justified with indents to seperate paragraphs
#	1 - Text is left-justified without indents to seperate paragraphs
#	2 - All text is indented and needs to be out-dented.
#-------------------------------------------------------------------------
#-------------------------------------------------------------------------
# S_DoFormatAnalysis
#	If an article is left-justified with indents
#-------------------------------------------------------------------------
sub S_DoFormatAnalysis {
	local ($aInFileName, $aOutDir) = @_;
	local ($lOutFileName);
	local ($lArticleFormat);

	open (INFILE, $aInFileName) || die "Could not open $aInFileName for input\n";
	open (OUTFILE, ">bob.txt");
	print "Doing format analysis for $aInFileName:\n";

	while ( <INFILE> ) {
		# Call a routine that will find the next story article and pull the text
		# into the global "gText" and the subject line into the global "gSubject"
		if ( &S_GetNextStory() == 1 )
		{

		}
	}

	close (OUTFILE);
	close (INFILE);

}	# S_PareseTextFile

#-------------------------------------------------------------------------
# S_CleanSubjectText
#-------------------------------------------------------------------------
sub S_CleanSubjectText {
	local ($aSubject) = @_;

	chop ($aSubject);
	$aSubject =~ s/Subject: //;
	$aSubject =~ s/Subject://;
	$aSubject =~ s/\*//g;
	$aSubject =~ s/\(//g;
	$aSubject =~ s/\)//g;
	$aSubject =~ s/\{//g;
	$aSubject =~ s/\}//g;
	$aSubject =~ s/\[//g;
	$aSubject =~ s/\]//g;
	$aSubject =~ s/\<//g;
	$aSubject =~ s/\>//g;
	$aSubject =~ s/_//g;
	$aSubject =~ s/-//g;
	$aSubject =~ s/\~//g;
	$aSubject =~ s/\!//g;
	$aSubject =~ tr/a-z/A-Z/;	# Upper case everything
	$aSubject =~ s/\"//g;
	$aSubject =~ s/\'//g;
	$aSubject =~ s/THE //g;
	$aSubject =~ s/A //g;
	$aSubject =~ s/\(//g;
	$aSubject =~ s/ //g;

	return ($aSubject);

}	# S_CleanSubjectText

#-------------------------------------------------------------------------
# S_GetTxtName
#	This routine will take a copy of the "Subject:..." line and attempt
#	to create a alphabetical file name that this story should go into.
#
#	As a default, the name "unk.txt" will be returned
#-------------------------------------------------------------------------
sub S_GetTxtName {
	local ($aSubject, $aOutDir) = @_;

	local ($lFirstChar, $lFileName, $lFinished, $lIndex, $lIndexStr);
	local ($i);

	# First we need to trim off the leading part of the subject line
	$aSubject = &S_CleanSubjectText ($aSubject);

	# Now create the first character of the file name
	$lFirstChar = substr ($aSubject, 0, 1);
	if ( $lFirstChar EQ "" ){
		$lFirstChar = "0";
	}

	# print "($lFirstChar) - First char\n";

	# We want something like "D00.TXT" for files starting with "D".  But
	# these files could grow so if a "D00.TXT" already exists that is too
	# big, we want to provide a file name like "D01.TXT".
	$lFileName = $aOutDir . $lFirstChar . "00.TXT";

	$lIndex = 0;
	$lFinished = $FALSE;
	# while ( $lFinished == $FALSE )
	{
		# $lIndexStr = sprintf ("%2d", $lIndex);

		# $lFileName = $aOutDir.$lFirstChar.$lIndexStr.".TXT";
		$lFinished = $TRUE;
	}

	### Examine text file to see if it is uuencoded here.  If so,
	### change the file name.  Do this by examining some lines in the
	### middle of the text buffer to see how long it is, and if it starts
	### with upper case "M" chars.
	$i = $#gText;
	$i = int ($i / 2);
	if (
		(substr ($gText[$i], 0, 1) EQ "M" && length ($gText[$i]) == 62) &&
		(substr ($gText[$i + 1], 0, 1) EQ "M" && length ($gText[$i + 1]) == 62)
	   )
	{
		# This is a uuencoded article and must be put in a different file name
		$lFileName = $aOutDir . "001.UUE";

	}

	return ($lFileName);
}	# S_GetTxtName


#-------------------------------------------------------------------------
# S_GetNextStory
#	This routine will read the next story in the current open INFILE
#	and store it in the global gText.  The "Subject:" line will be stored
#	in the global gSubject.
#
#	Returns:	1 - A story was read
#				0 - EOF
#
#-------------------------------------------------------------------------
sub S_GetNextStory {

	local ($lFinished, $lLine);

	$lFinished = $FALSE;
	$gSubject = "";
	@gText = ();

	while ( <INFILE> )
	{
		$lLine = $_;

		push (@gText, $lLine);

		if ( index ($lLine, "Subject:") == 0 ) {
			# Note: some articles contain a copy of another article that has a
			# "Subject:" line in it.  We only want the first "Subject:" line.
			if ( $gSubject EQ "" ) {
				$gSubject = $lLine;
			}
		}

		if ( index ($lLine, "{--------") > -1 ) {
			push (@gText, "\n");
			$lFinished = $TRUE;
			return (1);
		}

	}

	# We may have hit the end of the file, but still got an
	# article.  See what the return code should be
	if ( $gSubject EQ "" )	{
		return (0);
	}

	return (1);

}	# S_GetNextStory

#-------------------------------------------------------------------------
# S_ParseTextFile
#	This routine will take a text file and read each story and write
#	each story out to a different file based upon the subject line.
#
#-------------------------------------------------------------------------
sub S_ParseTextFile {
	local ($aInFileName, $aOutDir) = @_;
	local ($lOutFileName);

	open (INFILE, $aInFileName) || die "Could not open $aInFileName for input\n";
	open (OUTFILE, ">bob.txt");
	print "Processing $aInFileName:\n";

	while ( <INFILE> ) {
		# Call a routine that will find the next story article and pull the text
		# into the global "gText" and the subject line into the global "gSubject"
		if ( &S_GetNextStory() == 1 )
		{
			# Examine the subject line to determine what
			# the output file name should be
			print OUTFILE "    $gSubject";
			$lOutFileName = &S_GetTxtName($gSubject, $aOutDir);

			print "        $aInFileName - $lOutFileName\n";
			print OUTFILE "        $lOutFileName\n";

			# Now write the story text to the output file name
			open (TXTFILE, ">>$lOutFileName") || die "Could not open $lOutFileName for output!\n";
			print TXTFILE @gText;
			close (TXTFILE);
		}
	}

	close (OUTFILE);
	close (INFILE);

}	# S_PareseTextFile

#-------------------------------------------------------------------------
# S_BreakFile
# This routine will take a storie file and break each storie into a
# individual file.  It will take the "Subject:" line of each story and
# add it to an array.
# Later, this array will be sorted and all of the individual storie articles
# will be merged into one new file in sorted order.
#-------------------------------------------------------------------------
sub S_BreakFile {
	local ($aInFileName) = @_;
	local ($i, $lFileName);
	local (%lSubjectArray);

	%lSubjectArray = ();

	open (INFILE, $aInFileName) || die "Could not open $aInFileName for input\n";
	print "Sorting $aInFileName:\n";
	$i = 1;
	while ( <INFILE> ) {
		# Call a routine that will find the next story article and pull the text
		# into the global "gText" and the subject line into the global "gSubject"
		if ( &S_GetNextStory() == 1 ) {

			# Get a temp file name to hold this story
			$lFileName = "t" . sprintf ("%04d", $i) . ".tmp";
			# print "$lFileName - $gSubject";

			# Add this subject line to our array
			# $lSubjectArray{$lFileName} = $gSubject;
			$gSubject = &S_CleanSubjectText ($gSubject);	# Uppcase and clean up

			$lSubjectArray{$gSubject} = $lFileName;

			# Write the story to the temp file
			open (TXTFILE, ">$lFileName") || die "Could not open $lFileName for output!\n";
			print TXTFILE @gText;
			close (TXTFILE);
			$i++;
		}
	}
	close (INFILE);


	# Now in memory we have all the "Subject:..." lines and the file
	# names for each story.  Sort the "Subject:.." lines and re-assemble
	# the entire file in sorted order.

	local ($lSubject, $lOldFileName);
	$lOldFileName = "_" . $aInFileName;
	rename ($aInFileName, $lOldFileName);
	open (OUTFILE, ">$aInFileName") || die ("Cannot open $aInFileName for output\n");

	foreach $lSubject (sort (keys(%lSubjectArray))) {
		$lFileName = $lSubjectArray{$lSubject};
		print "Out: $lFileName - $lSubject\n";

		# Grab the story file and put it's lines into the output file
		open (INFILE, "$lFileName") || die ("Cannot open $lFileName for input!\n");
		while ( <INFILE> ) 	{
			print OUTFILE $_;
		}
		close (INFILE);
		# unlink (INFILE);	# Delete the temp file
	}

	close (OUTFILE);


	# Delete the temp files
	system "del *.tmp";

	print "Original file moved to : $lOldFileName\n";
	print "Sorted output written to : $aInFileName\n";



}	# S_BreakFile


#-------------------------------------------------------------------------
# S_SortStories
# This routine will sort the stories found in ONE text file to itself
#
#-------------------------------------------------------------------------
sub S_SortStories {

    &S_BreakFile ("c:\\temp\\temp\\comb.txt");
}	# S_SortStories

#-------------------------------------------------------------------------
# S_CompareFileSizes
# Many routines take a file, and filter it to another file. Sometimes
# there is a problem and the output file is much smaller than the input
# file. In this case, we want to exit so we don't trash things.
# This routine checks 2 file names and compares the sizes. If the output
# is too small (less than 90%) of the input, a message is printed and
# the program will hard EXIT
#-------------------------------------------------------------------------
sub S_TestFileSizes {
	local ($aInFile, $aOutFile) = @_;
	local ($lInFileSize, $lOutFileSize, $lSize);

	if ( (-e $aInFile) && (-e $aOutFile) ) 	{
		$lInFileSize = -s $aInFile;
		$lOutFileSize = -s $aOutFile;

		# The output is often a bit smaller. Allow 10%
		$lSize = $lInFileSize * 0.90;
		if ( $lOutFileSize < $lSize ) {
			print "Error: In/Out files ($aInFile / $aOutFile) sizes are ($lInFileSize / $lOutFileSize)\n";
			print "       This is greater than a 10 % difference\n";
			print "       Exiting program to prevent loss\n";
			exit (1)
		}
	} else {

		print "Error: one of the input/output files ($aInFile, $aOutFile) does not exist\n";
		exit (1);
	}

}	# S_TestFileSizes

#-------------------------------------------------------------------------
# S_EraseFile
# This routine will take a file name and test to see if it exists. If so,
# it will erase it by using the dos DEL routine.
#-------------------------------------------------------------------------
sub S_EraseFile {
	local ($aFileName) = @_;
	local ($lCmd) = "del $aFileName";

	if (-e $aFileName) {
		system $lCmd;
	}
}	# S_EraseFile

#-------------------------------------------------------------------------
# S_SortTextStories
# This routine will look for all the .TXT files in the source directory
# and for each file found it will break the file up into individual
# text files
#  Output is A00.TXT, B00.TXT ...
#-------------------------------------------------------------------------
sub S_SortTextStories {

		# S_ParseTextFile (<src file name> , <dest directory> );
    &S_ParseTextFile ("storiesa.txt", "C:\\TEMP\\temp\\");
    &S_ParseTextFile ("storiesb.txt", "C:\\TEMP\\temp\\");
    &S_ParseTextFile ("storiesc.txt", "C:\\TEMP\\temp\\");
    &S_ParseTextFile ("storiesd.txt", "C:\\TEMP\\temp\\");
    &S_ParseTextFile ("storiese.txt", "C:\\TEMP\\temp\\");
    &S_ParseTextFile ("storiesf.txt", "C:\\TEMP\\temp\\");
    &S_ParseTextFile ("storiesh.txt", "C:\\TEMP\\temp\\");
    &S_ParseTextFile ("storiesi.txt", "C:\\TEMP\\temp\\");
    &S_ParseTextFile ("comb.txt", "C:\\TEMP\\temp\\");
    &S_ParseTextFile ("new1.txt", "C:\\TEMP\\temp\\");

}	# S_SortTextStories


#-------------------------------------------------------------------------
# S_StripCommonHeadings -
# Looks for common things that follow the word "Subject: "
# and strips them off:
# Subject: Repost - xxx         Subject: xxx
# Subject: Repost- xxx			Subject: xxx
# Subject: Repost-xxx           Subject: xxx
# Subject: Repost : xxx         Subject: xxx
# Subject: Repost: xxx          Subject: xxx
# Subject: Repost:xxx           Subject: xxx
#-------------------------------------------------------------------------
sub S_StripCommonHeadings {
	local ($aInLine, $aTLA) = @_;


	$aInLine =~ s/Subject: $aTLA - /Subject: /gii;
	$aInLine =~ s/Subject: $aTLA -/Subject: /gii;
	$aInLine =~ s/Subject: $aTLA- /Subject: /gii;
	$aInLine =~ s/Subject: $aTLA-/Subject: /gii;


	$aInLine =~ s/Subject: $aTLA : /Subject: /gii;
	$aInLine =~ s/Subject: $aTLA :/Subject: /gii;
	$aInLine =~ s/Subject: $aTLA: /Subject: /gii;
	$aInLine =~ s/Subject: $aTLA:/Subject: /gii;

    $aInLine =~ s/Subject: $aTLA, /Subject: /gii;
    $aInLine =~ s/Subject: $aTLA! /Subject: /gii;

	$aInLine =~ s/Subject: $aTLA;/Subject: /gii;

	$aInLine =~ s/Subject: $aTLA /Subject: /gii;

	return ($aInLine);

}	# S_StripCommonHeadings


#-------------------------------------------------------------------------
# S_StripTLA - Removes common Three letter acrynoms like:
# 	{ASSM}
# 	(ASSM)
# 	[ASSM]
# 	ASSM -
# 	ASSM-
# 	ASSM
#-------------------------------------------------------------------------
sub S_StripTLA {
	local ($aInLine, $aTLA) = @_;

	$aInLine =~ s/ \{$aTLA\} / /gii;
	$aInLine =~ s/ \{$aTLA\}/ /gii;
	$aInLine =~ s/\{$aTLA\}/ /gii;

	$aInLine =~ s/ \[$aTLA\] / /gii;
	$aInLine =~ s/ \[$aTLA\]/ /gii;
	$aInLine =~ s/\[$aTLA\]/ /gii;

	$aInLine =~ s/ \($aTLA\) / /gii;
	$aInLine =~ s/ \($aTLA\)/ /gii;
	$aInLine =~ s/\($aTLA\)/ /gii;

	return ($aInLine);

}	# S_StripTLA
#-------------------------------------------------------------------------
# S_ScrubSubjectLine
#-------------------------------------------------------------------------
sub S_ScrubSubjectLine {
	local ($lLine) = @_;
	local ($lOutLine) = "";


	# Look for common things in {} () []
	$lLine = &S_StripTLA ($lLine, "ASSM");
	$lLine = &S_StripTLA ($lLine, "ASSD");
	$lLine = &S_StripTLA ($lLine, "ASS");
	$lLine = &S_StripTLA ($lLine, "RE");
	$lLine = &S_StripTLA ($lLine, "RP");

	# Look for common things like "Subject: RP:"
	$lLine = &S_StripCommonHeadings ($lLine, "RP by req.");
	$lLine = &S_StripCommonHeadings ($lLine, "RP");
	$lLine = &S_StripCommonHeadings ($lLine, "RE");
	$lLine = &S_StripCommonHeadings ($lLine, "REPOST");
	$lLine = &S_StripCommonHeadings ($lLine, "NEW STORY");
	$lLine = &S_StripCommonHeadings ($lLine, "STORY");
	$lLine = &S_StripCommonHeadings ($lLine, "NEW");

	# Look for some other common things that dont fit regular patterns

	$lLine =~ s/Subject: Krinsen\'s collection: /Subject: /gi;

	$lLine =~ s/Subject: sex \"/Subject: \"/g;

	$lLine =~ s/Subject: -\"/Subject: \"/g;

	# This funny thing often appears
	$lLine =~ s/\<\*\>//g;

#		$lLine =~ s/ Re: //gi;
#		$lLine =~ s/Rp by Rq: //gi;
#		$lLine =~ s/(Anonymouse)//gi;
#		$lLine =~ s/(Repost) //gi;
#		$lLine =~ s/(Repost)//gi;
#		$lLine =~ s/Another 120 Stories //gi;
#
	# We may have left some extra spaces
	$lLine =~ s/  / /gi;
	$lLine =~ s/  / /gi;

	return ($lLine);
}	# S_ScrubSubjectLine


#-------------------------------------------------------------------------
# S_HandleAuthor
#  Often, Subject lines start with the authors name like:
# 		Subject: (PJ)
# 		Subject: {Kellis}
# This routine will take a "Subject:" line, look for author names at
# the begining and move the text to the end of the line.
#-------------------------------------------------------------------------
sub S_HandleAuthor {
	local ($aLine) = @_;
	local ($lEndChar);
	local ($lAuthorName);

	# Look for Ann Douglas stories
	if ( $aLine =~ /Subject: AnnD/i ) {
		$aLine =~ s/Subject: AnnD/Subject: /gi;
		$aLine .= " {AnnD}";
	}

	if ( $aLine =~ /Subject: Kristen's collection: /i ) {
		$aLine =~ s/Subject: Kristen's collection: /Subject: /gi;
	}

	# Look for the word "Subject: " followed by "({["
	if ( $aLine =~ /Subject: [\(\{\[]/ ) {

		# The opening "(" is at char pos 9. Find the ending character
		$lEndChar = 0;
		if ( index ($aLine, "(") == 9 ) {
			$lEndChar = index ($aLine, ")");
		} elsif ( index ($aLine, "{") == 9 ) {
			$lEndChar = index ($aLine, "}");
		} elsif ( index ($aLine, "[") == 9 ) {
			$lEndChar = index ($aLine, "]");
		}

		if ( $lEndChar > 9 ) {
			# Grab everything between () as the authors name
			$lAuthorName = substr ($aLine, 9, $lEndChar - 8);

			# Remove the authors name from the begining
			$aLine = "Subject: " . substr ($aLine, $lEndChar + 1);

			# Put the authors name at the end between  {} chars
			chop ($lAuthorName);	# Trim trailing ) char
			$aLine .= " {" . substr ($lAuthorName, 1) . "}";
		}


	}


	# We may have left some extra spaces
	$aLine =~ s/  / /gi;

	return ($aLine);


}	# S_HandleAuthor


#-------------------------------------------------------------------------
# S_HandleChapters
# This routine looks for things like: (1/2) and 5/11 and reformats
# them to "[1/2]" or "[05/11]"
#
#-------------------------------------------------------------------------
sub S_HandleChapters {
	local ($aLine) = @_;
	local ($x, $y);

	# See if the line already has brackets around chapter numbers
	if ( $aLine =~ /\[\d/ ) {
		# Nothing to do
		# print "Already has brackets: $aLine\n";
		return ($aLine);
	}

	# Convert roman numerials
	$aLine =~ s/ III / 3 /;
	$aLine =~ s/ II / 2 /;
	$aLine =~ s/ IV / 4 /;
	$aLine =~ s/ V / 5 /;
	$aLine =~ s/ VI / 6 /;
	$aLine =~ s/ VII / 7 /;
	$aLine =~ s/ IIX / 8 /;
	$aLine =~ s/ IX / 9 /;
	$aLine =~ s/ X / 10 /;
	$aLine =~ s/ XIII / 13 /;
	$aLine =~ s/ XII / 12 /;
	$aLine =~ s/ XI / 11 /;


	# Convert some text

#	$aLine =~ s/ one/ 1/gi;
#	$aLine =~ s/ two/ 2/gi;
#	$aLine =~ s/ three/ 3/gi;
#	$aLine =~ s/ four/ 4/gi;
#	$aLine =~ s/ five/ 5/gi;
#	$aLine =~ s/ six/ 6/gi;
#	$aLine =~ s/ seven/ 7/gi;
#	$aLine =~ s/ eight/ 8/gi;
#	$aLine =~ s/ nine/ 9/gi;
#	$aLine =~ s/ ten/ 10/gi;

	# Look for any two numbers like "(x/x)" and convert to " [x/x] "
	if ( $aLine =~ /\(\d\/\d\)/  ) {
		$aLine =~ s/\((\d)\/(\d)\)/ \[$1\/$2\] /g;
		# print "Added [x/x]: $aLine\n";
		return $aLine;
	}

	# Look for (1/2) type patterns. Replace with [1/2]
	if ( $aLine =~ /\(\d\)/ ) {
		# Replace the "()" chars with "[]" chars
		$aLine =~ s/\((\d)\/(\d)\)/ \[$1\/$2\] /;
		$aLine =~ s/\((\d)\/(\d\d)\)/ \[0$1\/$2\] /;
		$aLine =~ s/\((\d\d)\/(\d\d)\)/ \[$1\/$2\] /;
		# print "Replaced parens with brackets: $aLine\n";
		return ($aLine);
	}

	# Look for bare numbers sitting out like "2/5"
	if ( $aLine =~ /\d\/\d/ ) {
		$aLine =~ s/ (\d\d\d)\/(\d\d\d)/\ \[$1\/$2\] /;
		$aLine =~ s/ (\d\d)\/(\d\d\d)/\ \[0$1\/$2\] /;
		$aLine =~ s/ (\d)\/(\d\d\d)/\ \[00$1\/$2\] /;

		$aLine =~ s/ (\d\d)\/(\d\d)/\ \[$1\/$2\] /;
		$aLine =~ s/ (\d)\/(\d\d)/\ \[0$1\/$2\] /;

		$aLine =~ s/ (\d)\/(\d)/\ \[$1\/$2\] /;
		# print "Added Brackets: $aLine\n";
		return ($aLine);
	}

	# Look for chapter indicators like: "3 of 5" and make it " [3/5] "
	if ( $aLine =~ /\d of \d/ ) {
		$aLine =~ s/(\d\d) of (\d\d)/ \[$1\/$2\]/g;
		$aLine =~ s/(\d) of (\d\d)/ \[0$1\/$2\]/g;
		$aLine =~ s/(\d) of (\d)/ \[$1\/$2\]/g;
		return ($aLine);
	}

	# Look for text like: "part x"
	if ( $aLine =~ /part \d/i ) {
		$aLine =~ s/part (\d\d\d)/ \[$1\/\?\?\?\]/gi;
		$aLine =~ s/part (\d\d)/ \[$1\/\?\?\]/gi;
		$aLine =~ s/part (\d)/ \[$1\/\?\]/gi;
		return ($aLine);
	}

	return ($aLine);
}	# S_HandleChapters
#-------------------------------------------------------------------------
# S_CleanSubject
# This routine will take both an input and output file name and write
# the input file to the output file name. When it finds a line that
# begins with "Subject:", it will attempt to reformt it and clean
# it up.
#-------------------------------------------------------------------------
sub S_CleanSubject {
    local ($lInFileName, $lOutFileName) = @_;
	local ($lInLine, $lOutLine);

    system "del $lOutFileName";

    open (INFILE, $lInFileName) || die "Could not open $lInFileName for input\n";
    open (OUTFILE, ">$lOutFileName");

	while ( <INFILE> ) {
		$lInLine = $_;
		if ( index ($lInLine, "Subject:") == 0 ) {
			# Here is the stuff we need to trim
			$lOutLine = &S_aTLASubjectLine($lInLine);

			# print "$lOutLine\n";
		}

	}

	close (INFILE);
	close (OUTFILE);
}	# S_CleanSubject




#-------------------------------------------------------------------------
# S_FindKeycodes
#-------------------------------------------------------------------------
sub S_FindKeycodes {
	local ($lSubjectLine) = @_;
	local ($lPosA, $lPosB);

	# Set default values
	$gKeycodes = "";

	# Look for the obvious {author}
	$lPosA = index ($lSubjectLine, "(");
	if ( $lPosA != -1 )
	{
		$lPosB = index ($lSubjectLine, ")");

		# Strip out author name

		# Remove {author} from the string

		return ($lSubjectLine);

	}

	# Look for the magic string " bye "
	$lPosA = index ($lSubjectLine, " by ");



	return ($lSubjectLine);

}	# S_FindKeycodes




#-------------------------------------------------------------------------
# S_FindAuthor
#-------------------------------------------------------------------------
sub S_FindAuthor {
	local ($lSubjectLine) = @_;
	local ($lPosA, $lPosB);

	# Set default values
	$gAuthor = "";

	# Look for the obvious {author}
	$lPosA = index ($lSubjectLine, "{");
	if ( $lPosA != -1 )
	{
		$lPosB = index ($lSubjectLine, "}");

		# Strip out author name

		# Remove {author} from the string

		return ($lSubjectLine);

	}

	# Look for the magic string " bye "
	$lPosA = index ($lSubjectLine, " by ");



	return ($lSubjectLine);

}	# S_FindAuthor

#-------------------------------------------------------------------------
# S_FindPartNum
# This routine will take a input subject line and try to parse out
# if this is Part 1 of 1 or part 2 of 25.
#
# The return values will be stored in gPartNum and gTotalParts vars.
# This routine will return the subject line with the part numbers
# removed:
#  Input:   Subject: "My Story" [1/1] {me} (mf)
#  Output:  Subject: "My Story" {me} (mf)
#
# Input:	Subject: "The tail" (mf) {adrian} part nine of twenty-nine
# Output:	Subject: "The tail" (mf) {adrian}
#
#
#-------------------------------------------------------------------------
sub S_FindPartNum {
	local ($lSubjectLine) = @_;
	local ($lNewSubjectLine);
	local ($lPosA, $lPosB);

	# Set default values
	$gPartNum = 1;
	$gTotalParts = 1;
	$lNewSubjectLine = $lSubjectLine;

	# Look for the obvious [1/1]
	$lPosA = index ($lSubjectLine, "[1/1]");
	if ( $lPosA > -1) {
		$lNewSubjectLine =~ s/\[1\/1\]//;
		return ($lNewSubjectLine);
	}



	return ($lNewSubjectLine);

}	# S_FindPartNum

#-------------------------------------------------------------------------
# S_ParseSubject
# This routine will take a input subject line and try to break it out
# into individual pieces: title, author, part number, keycodes.
# Then it creates a new subject line of the form:
# 	Subject: "title" [X/Y] {Author} (Keycodes)
#
# Returns:		Number of errors. If any are encountered, we cannot
#				create a new subject line.
#
#-------------------------------------------------------------------------
sub S_ParseSubject {
	local ($lOrigLine) = @_;

	$gErrorCount = 0;

	# Find the part numbers first. If none, it becomes [1/1]
	$lOrigLine = &S_FindPartNum ($lOrigLine);

	# Find the authors name
	$lOrigLine = &S_FindAuthor($lOrigLine);

	# Find keycodes
	$lOrigLine = &S_FindKeycodes ($lOrigLine);


}	# S_ParseSubject

#-------------------------------------------------------------------------
# S_CleanSubject
#
# This routine will open a input file and output file and copy all the
# rows from one to the other.
# When it finds a row begining with "Subject:", it will try to re-format
# the line so it has the form:
# 	Subject: "title" [X/Y] {Author} (Keycodes)
#-------------------------------------------------------------------------
sub S_CleanSubject {
    local ($lInFileName, $lOutFileName) = @_;
	local ($lInLine, $lOldSubject, $lNewSubject);

	system "del $lOutFileName";

    print "CleanSubject: Input/Output is: ($lInFileName / $lOutFileName)\n";

	open (INFILE, "$lInFileName")   || die "Could not open $lInFileName for input\n";
	open (OUTFILE, ">$lOutFileName") || die "could not open $lOutFileName";

	# Read every line in the input file and write it to the
	# output file. If we see a "Subject:" line header, try and
	# parse it out.

	while ( <INFILE> ) {
		$lInLine = $_;
		chop ($lInLine);
		if ( index ($lInLine, "Subject:") == 0 ) {
			  $lOldSubjectLine = $lInLIne;

				# Scrub common crap from the subject line like "Re:",
				# Repost:, etc
				#
				$lNewSubject = &S_ScrubSubjectLine ($lInLine);


				# Look for authors names in the begining, move it to the end
				$lNewSubject = &S_HandleAuthor($lNewSubject);

				# Look for part text "1/2" or others and put them in brackets
				$lNewSubject = &S_HandleChapters ($lNewSubject);

			  # Try to parse out the title/author/parts/keycodes
			  # from the subject line. Then reconstruct the line
			  # using the format:
			  # Subject: "title" [x/y] {author} (keycodes)
			  #
			  # $lNewSubject = &S_ParseSubject ($lNewSubject);

			  $lNewSubject =~ s/  / /g;		# Clean extra spaces out
			  	# print "$lNewSubject\n";
				print OUTFILE "$lNewSubject\n";

		} else {
			print OUTFILE "$lInLine\n";
		}
	}


	close (OUTFILE);
	close (INFILE);

	print "CleanSubject: Output file is ($lOutFileName)\n";

}	# S_CleanSubject

#-------------------------------------------------------------------------
# S_FixSubjectLines
#-------------------------------------------------------------------------
sub S_FixSubjectLines {
	local ($aFileName) = @_;
	local ($lInFile, $lOutFile);
	local ($lCmd);

	# See if the parent routine gave us a file name
	if ( length ($aFileName) < 1 )
	{
		# Get the input file name
		system ("cls");
		printf "File Name: ";
		$lOutFile = <STDIN>;
		chop ($lOutFile);
	} else {
		$lOutFile = $aFileName;
	}

	if ( length ($lOutFile) > 3 ) {
		printf "Processing file ($lOutFile)\n";

		$lInFile = "_" . $lOutFile;
		# Make sure we don't have our temporary file already existing
		&S_EraseFile ($lInFile);
		system "rename $lOutFile $lInFile";

		# Call a routine that will read each line in the input file
		# and write it to the output file. It will look for
		# "Subject:" lines and try to clean them up.
		&S_CleanSubject ($lInFile, $lOutFile);
		print "Subject Lines fixed. (Input/Output): ($lInFile / $lOutFile)\n";

		# &S_BreakFile ($lOutFile);

	} else {
		printf "** NO INPUT FILE SPECIFIED **\n";
	}

	# Now make sure we did not cut our file in half
	&S_TestFileSizes ($lInFile, $lOutFile);

}	# S_FixSubjectLines



#-------------------------------------------------------------------------
# S_SortBySubject
#-------------------------------------------------------------------------
sub S_SortBySubject {
	local ($aFileName) = @_;
	local ($lOutFile);
	local ($lCmd);


	# See if the parent routine gave us a file name
	if ( length ($aFileName) < 1 )
	{
		# Get the input file name
		system ("cls");
		printf "File Name: ";
		$lOutFile = <STDIN>;
		chop ($lOutFile);
	} else {
		$lOutFile = $aFileName;
	}

	if ( length ($lOutFile) > 3 ) {
        printf "Sorting file ($lOutFile)\n";

		&S_BreakFile ($lOutFile);

	} else {
		printf "** NO INPUT FILE SPECIFIED **\n";
	}

	print "File sorted. Output file: $lOutFile\n";

}	# S_SortBySubject

#-------------------------------------------------------------------------
# S_FilterLine
# This routine will take an input line and decide if it should be
# filtered out.
# Returns:		0 - The line should be printed
#				3 - This line and the next two should be skipped
#
#-------------------------------------------------------------------------
sub S_FilterLine
{
	local ($aLine) = @_;
	local ($i);

   if ( $aLine =~ /^--$/ ) {
        return (1);
   }


   if ( $aLine =~ /^------------------------------------------------------------/ ) {
       print OUTFILE "{------------------------------------------------------------}\n";
       return 1;
   }

	# There is an array of things to look for
	foreach (@gFilterLines) {
		if ( $aLine =~ /^$_/i ) {
			return (1);
		}
	}

	# Now we look for more complicated things
	if ( $aLine =~ /^Warning\! Turns your wife\/lover into a Dominatrix./i ) {
		for ( $i = 0; $i < 4; $i++ )
		{
			$aLine = <INFILE>;	# Skip over lines
		}
		return (1);
	}

	if ( $aLine =~ /^The DOMestic discussion list has been going/i ) {
		for ( $i = 0; $i < 5; $i++ )
		{
			$aLine = <INFILE>;	# Skip over lines
		}
		return (1);
	}

	if ( $aLine =~ /^The DOMestic digest is free/i ) {
		for ( $i = 0; $i < 5; $i++ )
		{
			$aLine = <INFILE>;	# Skip over lines
		}
		return (1);
	}

    if ( $aLine =~ /Courtesy:/i ) {
        $aLine = <INFILE>;  # Skip over lines
		return (1);
	}

    if ( $aLine =~ /Pursuant to the Berne Convention,/i ) {
        while (length ($aLine) > 3) {
            $aLine = <INFILE>;  # Skip over lines
        }
		return (1);
	}


    if ( $aLine =~ /Do You Yahoo/i ) {
        while (length ($aLine) > 3) {
            $aLine = <INFILE>;  # Skip over lines
        }
		return (1);
	}

    if ( $aLine =~ /----- ASSM Moderation System Notice-/i ) {
        while (length ($aLine) > 3) {
            $aLine = <INFILE>;  # Skip over lines
        }
		return (1);
	}



}	# S_FilterLine


#-------------------------------------------------------------------------
# S_RemoveLines
# This routine will take an input and output file name and write the
# input to the output, removing some lines
#-------------------------------------------------------------------------
sub S_RemoveLines
{
	local ($aInFileName, $aOutFileName) = @_;
	local ($lInLine);
	local ($lSkipXLines);

	open (INFILE, "$aInFileName")   || die "Could not open $aInFileName for input\n";
	open (OUTFILE, ">$aOutFileName") || die "could not open $aOutFileName for output";

	while ( <INFILE> ) {
		$lInLine = $_;
		chop ($lInLine);

		# Call a routine to decide if we should print the current line
		# out, or skip this and the following X lines.

		$lSkipXLines = &S_FilterLine ($lInLine);
		if ( $lSkipXLines == 0 )
		{
			# Look for common bad chars and then print the line
            $lInLine =~ s/“/"/g;
            $lInLine =~ s/”/"/g;
            $lInLine =~ s/’/'/g;
			print OUTFILE "$lInLine\n";

			if ( index ($lInLine, "Subject:") == 0 ) {
				print ".";
			}

		} else {
			$lSkipXLines--;
			while ( $lSkipXLines > 0 ) {
				$lInLine = <INFILE>;
			}
		}

	}	# while <INFILE>


	close (OUTFILE);
	close (INFILE);
	print "\n";

}	# S_RemoveLines

#-------------------------------------------------------------------------
# S_StripExtraLines
# This routine will ask for a file name and filter un-wanted Usenet
# text lines from it
#-------------------------------------------------------------------------
sub S_StripExtraLines
{
	local ($aFileName) = @_;
	local ($lInFile, $lOutFile);
	local ($lOutFile);
	local ($lCmd);

	# See if the parent routine gave us a file name
	if ( length ($aFileName) < 1 )
	{
		# Get the input file name
		system ("cls");
		printf "File Name: ";
		$lOutFile = <STDIN>;
		chop ($lOutFile);
	} else {
		$lOutFile = $aFileName;
	}

	if ( length ($lOutFile) > 3 ) {
		printf "Stripping extra lines from ($lOutFile)\n";

		# Create a unique file name for the temporary file
		$lInFile = "_" . "$lOutFile";

		# delete any temp file that is left over
		&S_EraseFile ($lInFile);
		system ("rename $lOutFile $lInFile");

		# Call a routine that will read each line in the input file
		# and write it to the output file. It will try to remove
		# Garbage newsgroup lines

		&S_RemoveLines ($lInFile, $lOutFile);
		print "Extra Lines removed. (Input/Output): ($lInFile / $lOutFile)\n";

	} else {
		printf "** NO INPUT FILE SPECIFIED **\n";
	}

	# Now make sure we did not cut our file in half
	&S_TestFileSizes ($lInFile, $lOutFile);

}	# S_StripExtraLines


#-------------------------------------------------------------------------
# S_ProcessNewFile
# This routine will ask for a file name and do 3 things to the file:
#  - Clean up the "Subject:" header lines
#  - Strip extra Newsgroup and common "garbage" lines
#  - Sort the articles by "Subject:" headers
#
#-------------------------------------------------------------------------
sub S_ProcessNewFile
{
	local ($lInFile);
	local ($lOut1, $lOut2, $lOut3);
	local ($lCmd);

	# Get the input file name
	system ("cls");
	printf "File Name: ";
	$lInFile = <STDIN>;
	chop ($lInFile);

	if ( length ($lInFile) > 3 ) {
		printf "Processing file ($lInFile)\n";

		# Call a routine that will read each line in the input file
		# and write it to the output file. It will look for
		# "Subject:" lines and try to clean them up.
		&S_FixSubjectLines($lInFile);


		# Call a routine that will read each line in the input file
		# And strip out funny newsgroup lines.
		&S_StripExtraLines ($lInFile)

		# Finally, sort the entire text file by the Subject header
		&S_SortBySubject ($lInFile);

	} else {
		printf "** NO INPUT FILE SPECIFIED **\n";
	}


}	# S_ProcessNewFile

#-------------------------------------------------------------------------
# S_GetDirectorySummary
# This routine will take a base-directory as an input and return an
# associated array of the form:
# 		Directory Name | File Count | Byte Count
# The key to the array is Byte Count, padded with 13 zeros.
#-------------------------------------------------------------------------
sub S_GetDirectorySummary {
	local ($aBasePath) = @_;
	local (%lDirList) = ();				# Our return variable
	local ($lDirFile) = "c:\\dir.out";  # Output of the DIR command
	local ($lDirCmd) = "dir /s $aBasePath > $lDirFile";
	local ($lLine);
	local ($lDirName, $lFileCount, $lByteCount); # Stats on each dir

	# Run the DIR command to get a full list of files
	print "$lDirCmd\n";
    system ($lDirCmd);

	# Open the dir file and run through it, pulling out the
	# file count and byte sizes

	open (INFILE, "$lDirFile") || die "Cannot open $lDirFile for input";
	while ( <INFILE> ) {

		$lLine = $_;
		chop ($lLine);

		# Now we have to read the file and pull out each
		# directory name, the file count and the size of the
		# files.

		# Look for the header that indicates a new directory
		if ( index ($lLine, "Directory of ") > -1 ) {
			# Found the directory name
			$lDirName = substr ($lLine, 13);
            # We need to clear a field so the following routine can
            # know it's ok to look for the summary of the directory.
            # Otherwise the final summary of files & sizes will be
            # red and credited to a directory.
            $lFileCount = 0;
		}

		# Look for the string that indicates the end of each
		# directory listing

        if ( (index ($lLine, "file(s) ") > -1) && ($lFileCount == 0) &&
         index ($lLine, " 0 bytes") == -1
        ) {
            #print "$lLine\n";
			# Found the "X files ()   Y bytes" section
			# Pull out the file count first
			$lFileCount = substr ($lLine, 0, 11);
			$lFileCount =~ s/,//g;	# Get rid of commas in the file count
			$lFileCount =~ s/ //g;

			# Now pull out the number of bytes

			$lByteCount = substr ($lLine, 19);
			$lByteCount =~ s/,//g;	# Get rid of commas in the byte size
			$lByteCount =~ s/ bytes//;
			$lByteCount =~ s/ //g;
			if ( $lByteCount > 0 ) {
				# We need to pad the size of the files with zeros for
				# the key
				$lLine = sprintf ("%013d", $lByteCount);
				# print "$lLine\n";
				if ( $lDirList{$lLine} == undef ) {
					$lDirList{$lLine} = "$lDirName|$lFileCount|$lByteCount";
                    # print "$lDirName\n";
                    print "$lDirList{$lLine}\n";
				}
			}
		}
	}
	close (INFILE);

	return (%lDirList);

}	# S_GetDirectorySummary


#-------------------------------------------------------------------------
# S_CalcFilesForCD
# This routine will take the directory list from the parent and pull
# out the directories from largest to smallest to fill a CD Rom
#   Input:      aDirList - Associative array of the form:
#                   Dir Name | File Count | Byte Count
#
# xcopy c:\temp\p\bd\*.* c:\1\bd /T /I - This will create directories
# move /y c:\temp\p\bd\*.* c:\1\bd - This will create directories
#-------------------------------------------------------------------------
sub S_CalcFilesForCD {
    local ($aBatFile, $aBasePath, %aDirList) = @_;
	local (@MoveCmd) = ();
    local ($lKey, $lDirLine, $lByteSummary, $lPercentFull, $lLine);
    local ($lDirName, $lFileCount, $lByteCount);
    local ($lDestDir, $i, $lIsAVI);

    # Sort the list by size, largest to smallest but paying
    # attention to the minimum number of files rule

	open (OUTFILE, ">$aBatFile") || die "Cannot open $aBatFile for output";
    $lByteSummary = 0;
    foreach $lKey (sort high_to_low keys %aDirList) {

        $lDirLine = $lFileList{$lKey};
        ($lDirName, $lFileCount, $lByteCount) = split (/\|/, $lDirLine);

        # The AVI directory is special. Test for it
        $_ = $lDirLine;
        if (/AVI/) {
            $lIsAVI = 1;
        } else {
            # check for text
            $_ = $lDirLine;
            if (/TEXT/) {
                $lIsAVI = 1;
            } else {
                $lIsAVI = 0;
            }
        }

		# Now see if this directory is a canidate

        if ( ($lIsAVI > 0) || ($lFileCount > $gMIN_NUM_FILES) ) {


			# See if this directory would put us over our limit
			if ( ($lByteSummary + $lByteCount) < $gDISK_LIMIT ) {

				# It's safe to add these files

				$lByteSummary += $lByteCount;
				$lPercentFull = sprintf ("%4.1f",
					100 * ($lByteSummary / $gDISK_LIMIT));

				# Format a output line

				$lLine = sprintf ("%7d \t (%s\%) %s",
					$lByteCount, $lPercentFull, $lDirName);
				print OUTFILE "REM: $lLine\n";

				# Format a move command
				$i = length ($aBasePath);
                $lDestDir = "\\1" . substr ($lDirName, $i);

				push (@MoveCmd, "Move /y $lDirName\\*    $lDestDir");
            }
        }
    }

    print OUTFILE "\nREM:  Byte Summary = $lByteSummary\n";
    print OUTFILE "REM:  Minimum ($gMIN_NUM_FILES) files per directory\n\n";

	foreach $lDirName (@MoveCmd) {
		print OUTFILE "$lDirName\n";
	}
	# print "@MoveCmd";

	close OUTFILE;

	print "Output file is: $aBatFile\n";

} # S_CalcFilesForCD

#-------------------------------------------------------------------------
# S_TestDirectorySummary
#-------------------------------------------------------------------------
sub high_to_low {
	if ( $a < $b ) {
		1
	} elsif ($a == $b) {
		0;
	} elsif ($a > $b) {
		-1;
	}
}

sub S_TestDirectorySummary {

    local ($lLine, $lDirLine);
	local (%lFileList) = ();
    local ($gDISK_LIMIT) = 650000000 - 20000000;   # 2 gig for now
    local ($gMIN_NUM_FILES) = 100;       # Dir must have at least X files
	local ($lPercentFull);
    local ($lBasePath) = "c:\\temp\\p";
    # local ($lBasePath) = "c:\\";
	local ($lDirName, $lFileCount, $lByteCount);

	local ($lByteSummary) = 0;
	local ($lKey);

	%lFileList = &S_GetDirectorySummary ($lBasePath);

    &S_CalcFilesForCD ("c:\\temp\\makecd.bat", $lBasePath, %lFileList);



}   # S_TestDirectorySummary

#-------------------------------------------------------------------------
# S_PrintCDMenu
#-------------------------------------------------------------------------
sub S_PrintCDMenu {

    print "=============================================\n";
    print "              CD ROM Menu\n";
    print "             HTML Utilitys\n";
    print "=============================================\n";
    print "Please choose an option:\n\n";
    print "\t1 - Create Directory File\n";
    print "\t2 - \n";
    print "\t3 - \n";
    print "\t4 - \n";
    print "\t5 - \n";
    print "\t6 - \n";
    print "\t7 - \n";
    print "\t8 - \n";
    print "\t9 - \n";
    print "\n\n";
    print "\t\tChoice: ";

}  # PrintCDMenu


#-------------------------------------------------------------------------
# PrintMenu2 - Prints the menu
#-------------------------------------------------------------------------
sub PrintMenu2 {

    print "=============================================\n";
    print "              Main Menu\n";
    print "             HTML Utilitys\n";
    print "=============================================\n";
    print "Please choose an option:\n\n";
    print "\t1 - Clean up Subject headers\n";
    print "\t2 - Strip lines from file\n";
    print "\t3 - Sort a file by SUBJECT headings\n";
    print "\t4 - Do everything \n";
    print "\t5 - Analyze format\n";
    print "\t6 - Get Directory Summary\n";
    print "\t7 - \n";
    print "\t8 - \n";
    print "\t9 - \n";
    print "\n\n";
    print "\t\tChoice: ";

}  # PrintMenu2


#-------------------------------------------------------------------------
#  GetCDChoice
#-------------------------------------------------------------------------
sub GetCDChoice {

    local ($l_finished) = 0;
    local ($l_choice) = 0;

    while ( $l_finished == 0) {
        &PrintCDMenu ();

        chop ($l_choice = <STDIN>);

        if ($l_choice == 1) {

        } elsif ($l_choice == 2)  {
        } elsif ($l_choice == 3)  {
        } elsif ($l_choice == 4)  {
        } elsif ($l_choice == 5)  {
        } elsif ($l_choice == 6)  {
        } elsif ($l_choice == 7)  {
        } elsif ($l_choice == 8)  {
        } elsif ($l_choice == 9)  {
        } else {
            $l_finished = 1;
        }

    }


    $l_choice;

} # GetCDChoice



#-------------------------------------------------------------------------
# Menu - Provides a menu for choices.  Returns the choice number.
#  If the choice requires a path, this routine will ask for it and
#  error check the path before returning.  The path will be stored
#  in $g_Path;
#-------------------------------------------------------------------------
sub GetChoice {

    local ($l_finished) = 0;
    local ($l_choice) = 0;

    while ( $l_finished == 0) {
        &PrintMenu2 ();

        chop ($l_choice = <STDIN>);

        if ( ($l_choice > 0) && ($l_choice < 10) ) {
            $l_finished = 1;
        }
    }

    $l_choice;

} # GetChoice


#----------------------------------------------------------
#  Main
#----------------------------------------------------------
sub main {

	print "There are ($#ARGV) arguments\n";
	if ( $ARGV[0] != undef ) { print "Arg 1 = $ARGV[0]\n";}
	if ( $ARGV[1] != undef ) { print "Arg 2 = $ARGV[1]\n";}
	if ( $ARGV[2] != undef ) { print "Arg 3 = $ARGV[2]\n";}

#	while ( <> )
#	{
#		print "($_) \n";
#	}

    &S_TestDirectorySummary();
    local ($l_finished) = 1;

    while ( ! $l_finished )
    {
        $g_choice = &GetChoice();

        if ( $g_choice == 1 )
        {
            $l_finished = 1;
			&S_FixSubjectLines("");

        } elsif ( $g_choice == 2 ) {

            $l_finished = 1;
			&S_StripExtraLines("");

        } elsif ( $g_choice == 3 ) {
            $l_finished = 1;
			&S_SortBySubject ("");
        } elsif ( $g_choice == 4 ) {
			&S_ProcessNewFile ();
            $l_finished = 1;
        } elsif ( $g_choice == 5 ) {
			&S_AnalyzeFormat ();
            $l_finished = 1;
        } elsif ( $g_choice == 6 ) {
            &GetCDChoice();
        } elsif ( $g_choice == 7 ) {
            $l_finished = 1;
        } elsif ( $g_choice == 8 ) {
            $l_finished = 1;
        } elsif ( $g_choice == 9 ) {
            $l_finished = 1;
        }
    }


}

# End of main
